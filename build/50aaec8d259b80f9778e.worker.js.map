{"version":3,"sources":["webpack:///webpack/bootstrap 50aaec8d259b80f9778e","webpack:///./assets/solver_cubejs_worker.js","webpack:///./assets/vendor/cubejs/cube.js","webpack:///(webpack)/buildin/module.js","webpack:///./assets/vendor/cubejs/solve.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA,IAAG;AACH;;AAEA,qBAAoB,yCAAyC;AAC7D,EAAC;;AAED;AACA,mBAAkB,gBAAgB;;;;;;;;;;AClClC;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,wBAAuB,QAAQ;AAC/B;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,wBAAuB,SAAS;AAChC;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,wBAAuB,QAAQ;AAC/B;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,wBAAuB,SAAS;AAChC;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,QAAQ;AAC/B;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,wBAAuB,SAAS;AAChC;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAoC,SAAS;AAC7C;AACA;AACA;AACA,sBAAqB,QAAQ;AAC7B;AACA;AACA,wBAAuB,QAAQ;AAC/B;AACA;AACA;AACA,sBAAqB,SAAS;AAC9B;AACA;AACA,wBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,QAAQ;AAC7B,0BAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,SAAS;AAC9B,wBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,mCAAmC;AAC1E;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,mCAAmC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,sBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAoC,SAAS;AAC7C;AACA;AACA;AACA,sCAAqC,mCAAmC;AACxE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,yCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;AACA;AACA,IAAG;AACH;AACA;;AAEA,EAAC;;;;;;;;;;;ACzaD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA,6CAA4C,iCAAiC,OAAO,OAAO,6CAA6C,EAAE,WAAW;;AAErJ;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAwC,sCAAsC;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAwC,sCAAsC;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,mCAAmC;AACvE;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,uCAAsC,mCAAmC;AACzE;AACA;AACA;AACA;AACA;AACA,uCAAsC,mCAAmC;AACzE;AACA;AACA,uCAAsC,mCAAmC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,mCAAmC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,sCAAqC,6BAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,uCAAsC,mCAAmC;AACzE;AACA;AACA;AACA;AACA,sCAAqC,6BAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,0CAAyC,sCAAsC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,8BAA8B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,wBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,yBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,wBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,+CAA8C,sCAAsC;AACpF,+CAA8C,sCAAsC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,6CAA4C,sCAAsC;AAClF,8CAA6C,sCAAsC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAoC,mCAAmC;AACvE;AACA;AACA,sBAAqB,QAAQ;AAC7B;AACA,wBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,UAAU;AACxC;AACA;AACA;AACA,mCAAkC,UAAU;AAC5C;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,2BAA0B,QAAQ;AAClC;AACA,yBAAwB,QAAQ;AAChC;AACA,8BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA,2BAA0B,QAAQ;AAClC;AACA,yBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,yCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sDAAqD,mCAAmC;AACxF;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,mCAAmC;AAC7E;AACA;AACA;AACA;AACA,wCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,QAAQ;AAChC,4BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,2CAA0C,mCAAmC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,yCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD,mCAAmC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,yCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,mCAAmC;AAC7E;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAC","file":"50aaec8d259b80f9778e.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/build/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 50aaec8d259b80f9778e\n **/","var Cube = require(\"./vendor/cubejs/cube\");\nrequire(\"./vendor/cubejs/solve\");\n\nself.addEventListener(\"message\", function (e) {\n  if (e.data.name !== \"solve\") return;\n  var state = e.data.state;\n\n  // Slice our state into faces, so it's easy to manipulate\n  var faces = {};\n  \"ULFRBD\".split(\"\").forEach(function (face, idx) {\n    faces[face] = state.substring(idx*9, (idx+1)*9);\n  });\n\n  // Map our state to an unrotated one\n  var mapping = {};\n  Object.keys(faces).forEach(function (face) {\n    mapping[faces[face][4]] = face;\n  });\n  Object.keys(faces).forEach(function (face) {\n    faces[face] = faces[face].split(\"\").map(function (c) {\n      return (c in mapping) ? mapping[c] : c;\n    }).join(\"\");\n  });\n\n  // Solve!\n  var cst = \"URFDLB\".split(\"\").map(function (face) {\n    return faces[face];\n  }).join(\"\");\n  var alg = Cube.fromString(cst).solve();\n\n  self.postMessage({ name: \"solved\", state: state, alg: alg });\n});\n\nCube.initSolver();\nself.postMessage({ name: \"ready\" });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./assets/solver_cubejs_worker.js\n ** module id = 0\n ** module chunks = 0\n **/","// Generated by CoffeeScript 1.10.0\n(function() {\n  var BL, BR, Cube, DB, DBL, DF, DFR, DL, DLF, DR, DRB, FL, FR, UB, UBR, UF, UFL, UL, ULB, UR, URF, cornerColor, cornerFacelet, edgeColor, edgeFacelet, ref, ref1, ref2;\n\n  ref = [0, 1, 2, 3, 4, 5, 6, 7], URF = ref[0], UFL = ref[1], ULB = ref[2], UBR = ref[3], DFR = ref[4], DLF = ref[5], DBL = ref[6], DRB = ref[7];\n\n  ref1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], UR = ref1[0], UF = ref1[1], UL = ref1[2], UB = ref1[3], DR = ref1[4], DF = ref1[5], DL = ref1[6], DB = ref1[7], FR = ref1[8], FL = ref1[9], BL = ref1[10], BR = ref1[11];\n\n  ref2 = (function() {\n    var B, D, F, L, R, U;\n    U = function(x) {\n      return x - 1;\n    };\n    R = function(x) {\n      return U(9) + x;\n    };\n    F = function(x) {\n      return R(9) + x;\n    };\n    D = function(x) {\n      return F(9) + x;\n    };\n    L = function(x) {\n      return D(9) + x;\n    };\n    B = function(x) {\n      return L(9) + x;\n    };\n    return [[[U(9), R(1), F(3)], [U(7), F(1), L(3)], [U(1), L(1), B(3)], [U(3), B(1), R(3)], [D(3), F(9), R(7)], [D(1), L(9), F(7)], [D(7), B(9), L(7)], [D(9), R(9), B(7)]], [[U(6), R(2)], [U(8), F(2)], [U(4), L(2)], [U(2), B(2)], [D(6), R(8)], [D(2), F(8)], [D(4), L(8)], [D(8), B(8)], [F(6), R(4)], [F(4), L(6)], [B(6), L(4)], [B(4), R(6)]]];\n  })(), cornerFacelet = ref2[0], edgeFacelet = ref2[1];\n\n  cornerColor = [['U', 'R', 'F'], ['U', 'F', 'L'], ['U', 'L', 'B'], ['U', 'B', 'R'], ['D', 'F', 'R'], ['D', 'L', 'F'], ['D', 'B', 'L'], ['D', 'R', 'B']];\n\n  edgeColor = [['U', 'R'], ['U', 'F'], ['U', 'L'], ['U', 'B'], ['D', 'R'], ['D', 'F'], ['D', 'L'], ['D', 'B'], ['F', 'R'], ['F', 'L'], ['B', 'L'], ['B', 'R']];\n\n  Cube = (function() {\n    var faceNames, faceNums, parseAlg;\n\n    function Cube(other) {\n      var x;\n      if (other != null) {\n        this.init(other);\n      } else {\n        this.identity();\n      }\n      this.newCp = (function() {\n        var k, results;\n        results = [];\n        for (x = k = 0; k <= 7; x = ++k) {\n          results.push(0);\n        }\n        return results;\n      })();\n      this.newEp = (function() {\n        var k, results;\n        results = [];\n        for (x = k = 0; k <= 11; x = ++k) {\n          results.push(0);\n        }\n        return results;\n      })();\n      this.newCo = (function() {\n        var k, results;\n        results = [];\n        for (x = k = 0; k <= 7; x = ++k) {\n          results.push(0);\n        }\n        return results;\n      })();\n      this.newEo = (function() {\n        var k, results;\n        results = [];\n        for (x = k = 0; k <= 11; x = ++k) {\n          results.push(0);\n        }\n        return results;\n      })();\n    }\n\n    Cube.prototype.init = function(state) {\n      this.cp = state.cp.slice(0);\n      this.co = state.co.slice(0);\n      this.ep = state.ep.slice(0);\n      return this.eo = state.eo.slice(0);\n    };\n\n    Cube.prototype.identity = function() {\n      var x;\n      this.cp = [0, 1, 2, 3, 4, 5, 6, 7];\n      this.co = (function() {\n        var k, results;\n        results = [];\n        for (x = k = 0; k <= 7; x = ++k) {\n          results.push(0);\n        }\n        return results;\n      })();\n      this.ep = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n      return this.eo = (function() {\n        var k, results;\n        results = [];\n        for (x = k = 0; k <= 11; x = ++k) {\n          results.push(0);\n        }\n        return results;\n      })();\n    };\n\n    Cube.prototype.toJSON = function() {\n      return {\n        cp: this.cp,\n        co: this.co,\n        ep: this.ep,\n        eo: this.eo\n      };\n    };\n\n    Cube.prototype.asString = function() {\n      var c, corner, edge, i, k, l, len, m, n, o, ori, p, ref3, ref4, result;\n      result = [];\n      ref3 = [[4, 'U'], [13, 'R'], [22, 'F'], [31, 'D'], [40, 'L'], [49, 'B']];\n      for (k = 0, len = ref3.length; k < len; k++) {\n        ref4 = ref3[k], i = ref4[0], c = ref4[1];\n        result[i] = c;\n      }\n      for (i = l = 0; l <= 7; i = ++l) {\n        corner = this.cp[i];\n        ori = this.co[i];\n        for (n = m = 0; m <= 2; n = ++m) {\n          result[cornerFacelet[i][(n + ori) % 3]] = cornerColor[corner][n];\n        }\n      }\n      for (i = o = 0; o <= 11; i = ++o) {\n        edge = this.ep[i];\n        ori = this.eo[i];\n        for (n = p = 0; p <= 1; n = ++p) {\n          result[edgeFacelet[i][(n + ori) % 2]] = edgeColor[edge][n];\n        }\n      }\n      return result.join('');\n    };\n\n    Cube.fromString = function(str) {\n      var col1, col2, cube, i, j, k, l, m, o, ori, p, ref3;\n      cube = new Cube;\n      for (i = k = 0; k <= 7; i = ++k) {\n        for (ori = l = 0; l <= 2; ori = ++l) {\n          if ((ref3 = str[cornerFacelet[i][ori]]) === 'U' || ref3 === 'D') {\n            break;\n          }\n        }\n        col1 = str[cornerFacelet[i][(ori + 1) % 3]];\n        col2 = str[cornerFacelet[i][(ori + 2) % 3]];\n        for (j = m = 0; m <= 7; j = ++m) {\n          if (col1 === cornerColor[j][1] && col2 === cornerColor[j][2]) {\n            cube.cp[i] = j;\n            cube.co[i] = ori % 3;\n          }\n        }\n      }\n      for (i = o = 0; o <= 11; i = ++o) {\n        for (j = p = 0; p <= 11; j = ++p) {\n          if (str[edgeFacelet[i][0]] === edgeColor[j][0] && str[edgeFacelet[i][1]] === edgeColor[j][1]) {\n            cube.ep[i] = j;\n            cube.eo[i] = 0;\n            break;\n          }\n          if (str[edgeFacelet[i][0]] === edgeColor[j][1] && str[edgeFacelet[i][1]] === edgeColor[j][0]) {\n            cube.ep[i] = j;\n            cube.eo[i] = 1;\n            break;\n          }\n        }\n      }\n      return cube;\n    };\n\n    Cube.prototype.clone = function() {\n      return new Cube(this.toJSON());\n    };\n\n    Cube.prototype.randomize = (function() {\n      var mixPerm, randOri, randint, result;\n      randint = function(min, max) {\n        return min + (Math.random() * (max - min + 1) | 0);\n      };\n      mixPerm = function(arr) {\n        var i, k, max, r, ref3, ref4, ref5, results;\n        max = arr.length - 1;\n        results = [];\n        for (i = k = 0, ref3 = max - 2; 0 <= ref3 ? k <= ref3 : k >= ref3; i = 0 <= ref3 ? ++k : --k) {\n          r = randint(i, max);\n          if (i !== r) {\n            ref4 = [arr[r], arr[i]], arr[i] = ref4[0], arr[r] = ref4[1];\n            results.push((ref5 = [arr[max - 1], arr[max]], arr[max] = ref5[0], arr[max - 1] = ref5[1], ref5));\n          } else {\n            results.push(void 0);\n          }\n        }\n        return results;\n      };\n      randOri = function(arr, max) {\n        var i, k, ori, ref3;\n        ori = 0;\n        for (i = k = 0, ref3 = arr.length - 2; 0 <= ref3 ? k <= ref3 : k >= ref3; i = 0 <= ref3 ? ++k : --k) {\n          ori += (arr[i] = randint(0, max - 1));\n        }\n        return arr[arr.length - 1] = (max - ori % max) % max;\n      };\n      result = function() {\n        mixPerm(this.cp);\n        mixPerm(this.ep);\n        randOri(this.co, 3);\n        randOri(this.eo, 2);\n        return this;\n      };\n      return result;\n    })();\n\n    Cube.random = function() {\n      return (new Cube).randomize();\n    };\n\n    Cube.prototype.isSolved = function() {\n      var c, e, k, l;\n      for (c = k = 0; k <= 7; c = ++k) {\n        if (this.cp[c] !== c) {\n          return false;\n        }\n        if (this.co[c] !== 0) {\n          return false;\n        }\n      }\n      for (e = l = 0; l <= 11; e = ++l) {\n        if (this.ep[e] !== e) {\n          return false;\n        }\n        if (this.eo[e] !== 0) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    Cube.prototype.cornerMultiply = function(other) {\n      var from, k, ref3, ref4, to;\n      for (to = k = 0; k <= 7; to = ++k) {\n        from = other.cp[to];\n        this.newCp[to] = this.cp[from];\n        this.newCo[to] = (this.co[from] + other.co[to]) % 3;\n      }\n      ref3 = [this.newCp, this.cp], this.cp = ref3[0], this.newCp = ref3[1];\n      ref4 = [this.newCo, this.co], this.co = ref4[0], this.newCo = ref4[1];\n      return this;\n    };\n\n    Cube.prototype.edgeMultiply = function(other) {\n      var from, k, ref3, ref4, to;\n      for (to = k = 0; k <= 11; to = ++k) {\n        from = other.ep[to];\n        this.newEp[to] = this.ep[from];\n        this.newEo[to] = (this.eo[from] + other.eo[to]) % 2;\n      }\n      ref3 = [this.newEp, this.ep], this.ep = ref3[0], this.newEp = ref3[1];\n      ref4 = [this.newEo, this.eo], this.eo = ref4[0], this.newEo = ref4[1];\n      return this;\n    };\n\n    Cube.prototype.multiply = function(other) {\n      this.cornerMultiply(other);\n      this.edgeMultiply(other);\n      return this;\n    };\n\n    Cube.moves = [\n      {\n        cp: [UBR, URF, UFL, ULB, DFR, DLF, DBL, DRB],\n        co: [0, 0, 0, 0, 0, 0, 0, 0],\n        ep: [UB, UR, UF, UL, DR, DF, DL, DB, FR, FL, BL, BR],\n        eo: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n      }, {\n        cp: [DFR, UFL, ULB, URF, DRB, DLF, DBL, UBR],\n        co: [2, 0, 0, 1, 1, 0, 0, 2],\n        ep: [FR, UF, UL, UB, BR, DF, DL, DB, DR, FL, BL, UR],\n        eo: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n      }, {\n        cp: [UFL, DLF, ULB, UBR, URF, DFR, DBL, DRB],\n        co: [1, 2, 0, 0, 2, 1, 0, 0],\n        ep: [UR, FL, UL, UB, DR, FR, DL, DB, UF, DF, BL, BR],\n        eo: [0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0]\n      }, {\n        cp: [URF, UFL, ULB, UBR, DLF, DBL, DRB, DFR],\n        co: [0, 0, 0, 0, 0, 0, 0, 0],\n        ep: [UR, UF, UL, UB, DF, DL, DB, DR, FR, FL, BL, BR],\n        eo: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n      }, {\n        cp: [URF, ULB, DBL, UBR, DFR, UFL, DLF, DRB],\n        co: [0, 1, 2, 0, 0, 2, 1, 0],\n        ep: [UR, UF, BL, UB, DR, DF, FL, DB, FR, UL, DL, BR],\n        eo: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n      }, {\n        cp: [URF, UFL, UBR, DRB, DFR, DLF, ULB, DBL],\n        co: [0, 0, 1, 2, 0, 0, 2, 1],\n        ep: [UR, UF, UL, BR, DR, DF, DL, BL, FR, FL, UB, DB],\n        eo: [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1]\n      }\n    ];\n\n    faceNums = {\n      U: 0,\n      R: 1,\n      F: 2,\n      D: 3,\n      L: 4,\n      B: 5\n    };\n\n    faceNames = {\n      0: 'U',\n      1: 'R',\n      2: 'F',\n      3: 'D',\n      4: 'L',\n      5: 'B'\n    };\n\n    parseAlg = function(arg) {\n      var k, len, move, part, power, ref3, results;\n      if (typeof arg === 'string') {\n        ref3 = arg.split(/\\s+/);\n        results = [];\n        for (k = 0, len = ref3.length; k < len; k++) {\n          part = ref3[k];\n          if (part.length === 0) {\n            continue;\n          }\n          if (part.length > 2) {\n            throw 'Invalid move: ' + part;\n          }\n          move = faceNums[part[0]];\n          if (move === void 0) {\n            throw 'Invalid move: ' + part;\n          }\n          if (part.length === 1) {\n            power = 0;\n          } else {\n            if (part[1] === '2') {\n              power = 1;\n            } else if (part[1] === \"'\") {\n              power = 2;\n            } else {\n              throw 'Invalid move: ' + part;\n            }\n          }\n          results.push(move * 3 + power);\n        }\n        return results;\n      } else if (arg.length != null) {\n        return arg;\n      } else {\n        return [arg];\n      }\n    };\n\n    Cube.prototype.move = function(arg) {\n      var face, k, l, len, move, power, ref3, ref4, x;\n      ref3 = parseAlg(arg);\n      for (k = 0, len = ref3.length; k < len; k++) {\n        move = ref3[k];\n        face = move / 3 | 0;\n        power = move % 3;\n        for (x = l = 0, ref4 = power; 0 <= ref4 ? l <= ref4 : l >= ref4; x = 0 <= ref4 ? ++l : --l) {\n          this.multiply(Cube.moves[face]);\n        }\n      }\n      return this;\n    };\n\n    Cube.inverse = function(arg) {\n      var face, k, len, move, power, result, str;\n      result = (function() {\n        var k, len, ref3, results;\n        ref3 = parseAlg(arg);\n        results = [];\n        for (k = 0, len = ref3.length; k < len; k++) {\n          move = ref3[k];\n          face = move / 3 | 0;\n          power = move % 3;\n          results.push(face * 3 + -(power - 1) + 1);\n        }\n        return results;\n      })();\n      result.reverse();\n      if (typeof arg === 'string') {\n        str = '';\n        for (k = 0, len = result.length; k < len; k++) {\n          move = result[k];\n          face = move / 3 | 0;\n          power = move % 3;\n          str += faceNames[face];\n          if (power === 1) {\n            str += '2';\n          } else if (power === 2) {\n            str += \"'\";\n          }\n          str += ' ';\n        }\n        return str.substring(0, str.length - 1);\n      } else if (arg.length != null) {\n        return result;\n      } else {\n        return result[0];\n      }\n    };\n\n    return Cube;\n\n  })();\n\n  if (typeof module !== \"undefined\" && module !== null) {\n    module.exports = Cube;\n  } else {\n    this.Cube = Cube;\n  }\n\n}).call(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./assets/vendor/cubejs/cube.js\n ** module id = 1\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 2\n ** module chunks = 0\n **/","// Generated by CoffeeScript 1.10.0\n(function() {\n  var BL, BR, Cnk, Cube, DB, DBL, DF, DFR, DL, DLF, DR, DRB, FL, FR, Include, N_FLIP, N_FRtoBR, N_PARITY, N_SLICE1, N_SLICE2, N_TWIST, N_UBtoDF, N_URFtoDLF, N_URtoDF, N_URtoUL, UB, UBR, UF, UFL, UL, ULB, UR, URF, allMoves1, allMoves2, computeMoveTable, computePruningTable, factorial, key, max, mergeURtoDF, moveTableParams, nextMoves1, nextMoves2, permutationIndex, pruning, pruningTableParams, ref, ref1, rotateLeft, rotateRight, value,\n    slice1 = [].slice,\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  Cube = this.Cube || require('./cube');\n\n  ref = [0, 1, 2, 3, 4, 5, 6, 7], URF = ref[0], UFL = ref[1], ULB = ref[2], UBR = ref[3], DFR = ref[4], DLF = ref[5], DBL = ref[6], DRB = ref[7];\n\n  ref1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], UR = ref1[0], UF = ref1[1], UL = ref1[2], UB = ref1[3], DR = ref1[4], DF = ref1[5], DL = ref1[6], DB = ref1[7], FR = ref1[8], FL = ref1[9], BL = ref1[10], BR = ref1[11];\n\n  Cnk = function(n, k) {\n    var i, j, s;\n    if (n < k) {\n      return 0;\n    }\n    if (k > n / 2) {\n      k = n - k;\n    }\n    s = 1;\n    i = n;\n    j = 1;\n    while (i !== n - k) {\n      s *= i;\n      s /= j;\n      i--;\n      j++;\n    }\n    return s;\n  };\n\n  factorial = function(n) {\n    var f, i, m, ref2;\n    f = 1;\n    for (i = m = 2, ref2 = n; 2 <= ref2 ? m <= ref2 : m >= ref2; i = 2 <= ref2 ? ++m : --m) {\n      f *= i;\n    }\n    return f;\n  };\n\n  max = function(a, b) {\n    if (a > b) {\n      return a;\n    } else {\n      return b;\n    }\n  };\n\n  rotateLeft = function(array, l, r) {\n    var i, m, ref2, ref3, tmp;\n    tmp = array[l];\n    for (i = m = ref2 = l, ref3 = r - 1; ref2 <= ref3 ? m <= ref3 : m >= ref3; i = ref2 <= ref3 ? ++m : --m) {\n      array[i] = array[i + 1];\n    }\n    return array[r] = tmp;\n  };\n\n  rotateRight = function(array, l, r) {\n    var i, m, ref2, ref3, tmp;\n    tmp = array[r];\n    for (i = m = ref2 = r, ref3 = l + 1; ref2 <= ref3 ? m <= ref3 : m >= ref3; i = ref2 <= ref3 ? ++m : --m) {\n      array[i] = array[i - 1];\n    }\n    return array[l] = tmp;\n  };\n\n  permutationIndex = function(context, start, end, fromEnd) {\n    var i, maxAll, maxB, maxOur, our, permName;\n    if (fromEnd == null) {\n      fromEnd = false;\n    }\n    maxOur = end - start;\n    maxB = factorial(maxOur + 1);\n    if (context === 'corners') {\n      maxAll = 7;\n      permName = 'cp';\n    } else {\n      maxAll = 11;\n      permName = 'ep';\n    }\n    our = (function() {\n      var m, ref2, results;\n      results = [];\n      for (i = m = 0, ref2 = maxOur; 0 <= ref2 ? m <= ref2 : m >= ref2; i = 0 <= ref2 ? ++m : --m) {\n        results.push(0);\n      }\n      return results;\n    })();\n    return function(index) {\n      var a, b, c, j, k, m, o, p, perm, q, ref10, ref11, ref12, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, t, u, w, x, y, z;\n      if (index != null) {\n        for (i = m = 0, ref2 = maxOur; 0 <= ref2 ? m <= ref2 : m >= ref2; i = 0 <= ref2 ? ++m : --m) {\n          our[i] = i + start;\n        }\n        b = index % maxB;\n        a = index / maxB | 0;\n        perm = this[permName];\n        for (i = o = 0, ref3 = maxAll; 0 <= ref3 ? o <= ref3 : o >= ref3; i = 0 <= ref3 ? ++o : --o) {\n          perm[i] = -1;\n        }\n        for (j = p = 1, ref4 = maxOur; 1 <= ref4 ? p <= ref4 : p >= ref4; j = 1 <= ref4 ? ++p : --p) {\n          k = b % (j + 1);\n          b = b / (j + 1) | 0;\n          while (k > 0) {\n            rotateRight(our, 0, j);\n            k--;\n          }\n        }\n        x = maxOur;\n        if (fromEnd) {\n          for (j = q = 0, ref5 = maxAll; 0 <= ref5 ? q <= ref5 : q >= ref5; j = 0 <= ref5 ? ++q : --q) {\n            c = Cnk(maxAll - j, x + 1);\n            if (a - c >= 0) {\n              perm[j] = our[maxOur - x];\n              a -= c;\n              x--;\n            }\n          }\n        } else {\n          for (j = t = ref6 = maxAll; ref6 <= 0 ? t <= 0 : t >= 0; j = ref6 <= 0 ? ++t : --t) {\n            c = Cnk(j, x + 1);\n            if (a - c >= 0) {\n              perm[j] = our[x];\n              a -= c;\n              x--;\n            }\n          }\n        }\n        return this;\n      } else {\n        perm = this[permName];\n        for (i = u = 0, ref7 = maxOur; 0 <= ref7 ? u <= ref7 : u >= ref7; i = 0 <= ref7 ? ++u : --u) {\n          our[i] = -1;\n        }\n        a = b = x = 0;\n        if (fromEnd) {\n          for (j = w = ref8 = maxAll; ref8 <= 0 ? w <= 0 : w >= 0; j = ref8 <= 0 ? ++w : --w) {\n            if ((start <= (ref9 = perm[j]) && ref9 <= end)) {\n              a += Cnk(maxAll - j, x + 1);\n              our[maxOur - x] = perm[j];\n              x++;\n            }\n          }\n        } else {\n          for (j = y = 0, ref10 = maxAll; 0 <= ref10 ? y <= ref10 : y >= ref10; j = 0 <= ref10 ? ++y : --y) {\n            if ((start <= (ref11 = perm[j]) && ref11 <= end)) {\n              a += Cnk(j, x + 1);\n              our[x] = perm[j];\n              x++;\n            }\n          }\n        }\n        for (j = z = ref12 = maxOur; ref12 <= 0 ? z <= 0 : z >= 0; j = ref12 <= 0 ? ++z : --z) {\n          k = 0;\n          while (our[j] !== start + j) {\n            rotateLeft(our, 0, j);\n            k++;\n          }\n          b = (j + 1) * b + k;\n        }\n        return a * maxB + b;\n      }\n    };\n  };\n\n  Include = {\n    twist: function(twist) {\n      var i, m, o, ori, parity, v;\n      if (twist != null) {\n        parity = 0;\n        for (i = m = 6; m >= 0; i = --m) {\n          ori = twist % 3;\n          twist = (twist / 3) | 0;\n          this.co[i] = ori;\n          parity += ori;\n        }\n        this.co[7] = (3 - parity % 3) % 3;\n        return this;\n      } else {\n        v = 0;\n        for (i = o = 0; o <= 6; i = ++o) {\n          v = 3 * v + this.co[i];\n        }\n        return v;\n      }\n    },\n    flip: function(flip) {\n      var i, m, o, ori, parity, v;\n      if (flip != null) {\n        parity = 0;\n        for (i = m = 10; m >= 0; i = --m) {\n          ori = flip % 2;\n          flip = flip / 2 | 0;\n          this.eo[i] = ori;\n          parity += ori;\n        }\n        this.eo[11] = (2 - parity % 2) % 2;\n        return this;\n      } else {\n        v = 0;\n        for (i = o = 0; o <= 10; i = ++o) {\n          v = 2 * v + this.eo[i];\n        }\n        return v;\n      }\n    },\n    cornerParity: function() {\n      var i, j, m, o, ref2, ref3, ref4, ref5, s;\n      s = 0;\n      for (i = m = ref2 = DRB, ref3 = URF + 1; ref2 <= ref3 ? m <= ref3 : m >= ref3; i = ref2 <= ref3 ? ++m : --m) {\n        for (j = o = ref4 = i - 1, ref5 = URF; ref4 <= ref5 ? o <= ref5 : o >= ref5; j = ref4 <= ref5 ? ++o : --o) {\n          if (this.cp[j] > this.cp[i]) {\n            s++;\n          }\n        }\n      }\n      return s % 2;\n    },\n    edgeParity: function() {\n      var i, j, m, o, ref2, ref3, ref4, ref5, s;\n      s = 0;\n      for (i = m = ref2 = BR, ref3 = UR + 1; ref2 <= ref3 ? m <= ref3 : m >= ref3; i = ref2 <= ref3 ? ++m : --m) {\n        for (j = o = ref4 = i - 1, ref5 = UR; ref4 <= ref5 ? o <= ref5 : o >= ref5; j = ref4 <= ref5 ? ++o : --o) {\n          if (this.ep[j] > this.ep[i]) {\n            s++;\n          }\n        }\n      }\n      return s % 2;\n    },\n    URFtoDLF: permutationIndex('corners', URF, DLF),\n    URtoUL: permutationIndex('edges', UR, UL),\n    UBtoDF: permutationIndex('edges', UB, DF),\n    URtoDF: permutationIndex('edges', UR, DF),\n    FRtoBR: permutationIndex('edges', FR, BR, true)\n  };\n\n  for (key in Include) {\n    value = Include[key];\n    Cube.prototype[key] = value;\n  }\n\n  computeMoveTable = function(context, coord, size) {\n    var apply, cube, i, inner, j, k, m, move, o, p, ref2, results;\n    apply = context === 'corners' ? 'cornerMultiply' : 'edgeMultiply';\n    cube = new Cube;\n    results = [];\n    for (i = m = 0, ref2 = size - 1; 0 <= ref2 ? m <= ref2 : m >= ref2; i = 0 <= ref2 ? ++m : --m) {\n      cube[coord](i);\n      inner = [];\n      for (j = o = 0; o <= 5; j = ++o) {\n        move = Cube.moves[j];\n        for (k = p = 0; p <= 2; k = ++p) {\n          cube[apply](move);\n          inner.push(cube[coord]());\n        }\n        cube[apply](move);\n      }\n      results.push(inner);\n    }\n    return results;\n  };\n\n  mergeURtoDF = (function() {\n    var a, b;\n    a = new Cube;\n    b = new Cube;\n    return function(URtoUL, UBtoDF) {\n      var i, m;\n      a.URtoUL(URtoUL);\n      b.UBtoDF(UBtoDF);\n      for (i = m = 0; m <= 7; i = ++m) {\n        if (a.ep[i] !== -1) {\n          if (b.ep[i] !== -1) {\n            return -1;\n          } else {\n            b.ep[i] = a.ep[i];\n          }\n        }\n      }\n      return b.URtoDF();\n    };\n  })();\n\n  N_TWIST = 2187;\n\n  N_FLIP = 2048;\n\n  N_PARITY = 2;\n\n  N_FRtoBR = 11880;\n\n  N_SLICE1 = 495;\n\n  N_SLICE2 = 24;\n\n  N_URFtoDLF = 20160;\n\n  N_URtoDF = 20160;\n\n  N_URtoUL = 1320;\n\n  N_UBtoDF = 1320;\n\n  Cube.moveTables = {\n    parity: [[1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]],\n    twist: null,\n    flip: null,\n    FRtoBR: null,\n    URFtoDLF: null,\n    URtoDF: null,\n    URtoUL: null,\n    UBtoDF: null,\n    mergeURtoDF: null\n  };\n\n  moveTableParams = {\n    twist: ['corners', N_TWIST],\n    flip: ['edges', N_FLIP],\n    FRtoBR: ['edges', N_FRtoBR],\n    URFtoDLF: ['corners', N_URFtoDLF],\n    URtoDF: ['edges', N_URtoDF],\n    URtoUL: ['edges', N_URtoUL],\n    UBtoDF: ['edges', N_UBtoDF],\n    mergeURtoDF: []\n  };\n\n  Cube.computeMoveTables = function() {\n    var len, m, name, ref2, scope, size, tableName, tables;\n    tables = 1 <= arguments.length ? slice1.call(arguments, 0) : [];\n    if (tables.length === 0) {\n      tables = (function() {\n        var results;\n        results = [];\n        for (name in moveTableParams) {\n          results.push(name);\n        }\n        return results;\n      })();\n    }\n    for (m = 0, len = tables.length; m < len; m++) {\n      tableName = tables[m];\n      if (this.moveTables[tableName] !== null) {\n        continue;\n      }\n      if (tableName === 'mergeURtoDF') {\n        this.moveTables.mergeURtoDF = (function() {\n          var UBtoDF, URtoUL, o, results;\n          results = [];\n          for (URtoUL = o = 0; o <= 335; URtoUL = ++o) {\n            results.push((function() {\n              var p, results1;\n              results1 = [];\n              for (UBtoDF = p = 0; p <= 335; UBtoDF = ++p) {\n                results1.push(mergeURtoDF(URtoUL, UBtoDF));\n              }\n              return results1;\n            })());\n          }\n          return results;\n        })();\n      } else {\n        ref2 = moveTableParams[tableName], scope = ref2[0], size = ref2[1];\n        this.moveTables[tableName] = computeMoveTable(scope, tableName, size);\n      }\n    }\n    return this;\n  };\n\n  allMoves1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17];\n\n  nextMoves1 = (function() {\n    var face, lastFace, m, next, o, p, power, results;\n    results = [];\n    for (lastFace = m = 0; m <= 5; lastFace = ++m) {\n      next = [];\n      for (face = o = 0; o <= 5; face = ++o) {\n        if (face !== lastFace && face !== lastFace - 3) {\n          for (power = p = 0; p <= 2; power = ++p) {\n            next.push(face * 3 + power);\n          }\n        }\n      }\n      results.push(next);\n    }\n    return results;\n  })();\n\n  allMoves2 = [0, 1, 2, 4, 7, 9, 10, 11, 13, 16];\n\n  nextMoves2 = (function() {\n    var face, lastFace, len, m, next, o, p, power, powers, results;\n    results = [];\n    for (lastFace = m = 0; m <= 5; lastFace = ++m) {\n      next = [];\n      for (face = o = 0; o <= 5; face = ++o) {\n        if (!(face !== lastFace && face !== lastFace - 3)) {\n          continue;\n        }\n        powers = face === 0 || face === 3 ? [0, 1, 2] : [1];\n        for (p = 0, len = powers.length; p < len; p++) {\n          power = powers[p];\n          next.push(face * 3 + power);\n        }\n      }\n      results.push(next);\n    }\n    return results;\n  })();\n\n  pruning = function(table, index, value) {\n    var pos, shift, slot;\n    pos = index % 8;\n    slot = index >> 3;\n    shift = pos << 2;\n    if (value != null) {\n      table[slot] &= ~(0xF << shift);\n      table[slot] |= value << shift;\n      return value;\n    } else {\n      return (table[slot] & (0xF << shift)) >>> shift;\n    }\n  };\n\n  computePruningTable = function(phase, size, currentCoords, nextIndex) {\n    var current, depth, done, index, len, m, move, moves, next, o, ref2, table, x;\n    table = (function() {\n      var m, ref2, results;\n      results = [];\n      for (x = m = 0, ref2 = Math.ceil(size / 8) - 1; 0 <= ref2 ? m <= ref2 : m >= ref2; x = 0 <= ref2 ? ++m : --m) {\n        results.push(0xFFFFFFFF);\n      }\n      return results;\n    })();\n    if (phase === 1) {\n      moves = allMoves1;\n    } else {\n      moves = allMoves2;\n    }\n    depth = 0;\n    pruning(table, 0, depth);\n    done = 1;\n    while (done !== size) {\n      for (index = m = 0, ref2 = size - 1; 0 <= ref2 ? m <= ref2 : m >= ref2; index = 0 <= ref2 ? ++m : --m) {\n        if (!(pruning(table, index) === depth)) {\n          continue;\n        }\n        current = currentCoords(index);\n        for (o = 0, len = moves.length; o < len; o++) {\n          move = moves[o];\n          next = nextIndex(current, move);\n          if (pruning(table, next) === 0xF) {\n            pruning(table, next, depth + 1);\n            done++;\n          }\n        }\n      }\n      depth++;\n    }\n    return table;\n  };\n\n  Cube.pruningTables = {\n    sliceTwist: null,\n    sliceFlip: null,\n    sliceURFtoDLFParity: null,\n    sliceURtoDFParity: null\n  };\n\n  pruningTableParams = {\n    sliceTwist: [\n      1, N_SLICE1 * N_TWIST, function(index) {\n        return [index % N_SLICE1, index / N_SLICE1 | 0];\n      }, function(current, move) {\n        var newSlice, newTwist, slice, twist;\n        slice = current[0], twist = current[1];\n        newSlice = Cube.moveTables.FRtoBR[slice * 24][move] / 24 | 0;\n        newTwist = Cube.moveTables.twist[twist][move];\n        return newTwist * N_SLICE1 + newSlice;\n      }\n    ],\n    sliceFlip: [\n      1, N_SLICE1 * N_FLIP, function(index) {\n        return [index % N_SLICE1, index / N_SLICE1 | 0];\n      }, function(current, move) {\n        var flip, newFlip, newSlice, slice;\n        slice = current[0], flip = current[1];\n        newSlice = Cube.moveTables.FRtoBR[slice * 24][move] / 24 | 0;\n        newFlip = Cube.moveTables.flip[flip][move];\n        return newFlip * N_SLICE1 + newSlice;\n      }\n    ],\n    sliceURFtoDLFParity: [\n      2, N_SLICE2 * N_URFtoDLF * N_PARITY, function(index) {\n        return [index % 2, (index / 2 | 0) % N_SLICE2, (index / 2 | 0) / N_SLICE2 | 0];\n      }, function(current, move) {\n        var URFtoDLF, newParity, newSlice, newURFtoDLF, parity, slice;\n        parity = current[0], slice = current[1], URFtoDLF = current[2];\n        newParity = Cube.moveTables.parity[parity][move];\n        newSlice = Cube.moveTables.FRtoBR[slice][move];\n        newURFtoDLF = Cube.moveTables.URFtoDLF[URFtoDLF][move];\n        return (newURFtoDLF * N_SLICE2 + newSlice) * 2 + newParity;\n      }\n    ],\n    sliceURtoDFParity: [\n      2, N_SLICE2 * N_URtoDF * N_PARITY, function(index) {\n        return [index % 2, (index / 2 | 0) % N_SLICE2, (index / 2 | 0) / N_SLICE2 | 0];\n      }, function(current, move) {\n        var URtoDF, newParity, newSlice, newURtoDF, parity, slice;\n        parity = current[0], slice = current[1], URtoDF = current[2];\n        newParity = Cube.moveTables.parity[parity][move];\n        newSlice = Cube.moveTables.FRtoBR[slice][move];\n        newURtoDF = Cube.moveTables.URtoDF[URtoDF][move];\n        return (newURtoDF * N_SLICE2 + newSlice) * 2 + newParity;\n      }\n    ]\n  };\n\n  Cube.computePruningTables = function() {\n    var len, m, name, params, tableName, tables;\n    tables = 1 <= arguments.length ? slice1.call(arguments, 0) : [];\n    if (tables.length === 0) {\n      tables = (function() {\n        var results;\n        results = [];\n        for (name in pruningTableParams) {\n          results.push(name);\n        }\n        return results;\n      })();\n    }\n    for (m = 0, len = tables.length; m < len; m++) {\n      tableName = tables[m];\n      if (this.pruningTables[tableName] !== null) {\n        continue;\n      }\n      params = pruningTableParams[tableName];\n      this.pruningTables[tableName] = computePruningTable.apply(null, params);\n    }\n    return this;\n  };\n\n  Cube.initSolver = function() {\n    Cube.computeMoveTables();\n    return Cube.computePruningTables();\n  };\n\n  Cube.prototype.solve = function(maxDepth) {\n    var State, freeStates, moveNames, phase1, phase1search, phase2, phase2search, solution, state, x;\n    if (maxDepth == null) {\n      maxDepth = 22;\n    }\n    moveNames = (function() {\n      var face, faceName, m, o, power, powerName, result;\n      faceName = ['U', 'R', 'F', 'D', 'L', 'B'];\n      powerName = ['', '2', \"'\"];\n      result = [];\n      for (face = m = 0; m <= 5; face = ++m) {\n        for (power = o = 0; o <= 2; power = ++o) {\n          result.push(faceName[face] + powerName[power]);\n        }\n      }\n      return result;\n    })();\n    State = (function() {\n      function State(cube) {\n        this.parent = null;\n        this.lastMove = null;\n        this.depth = 0;\n        if (cube) {\n          this.init(cube);\n        }\n      }\n\n      State.prototype.init = function(cube) {\n        this.flip = cube.flip();\n        this.twist = cube.twist();\n        this.slice = cube.FRtoBR() / N_SLICE2 | 0;\n        this.parity = cube.cornerParity();\n        this.URFtoDLF = cube.URFtoDLF();\n        this.FRtoBR = cube.FRtoBR();\n        this.URtoUL = cube.URtoUL();\n        this.UBtoDF = cube.UBtoDF();\n        return this;\n      };\n\n      State.prototype.solution = function() {\n        if (this.parent) {\n          return this.parent.solution() + moveNames[this.lastMove] + ' ';\n        } else {\n          return '';\n        }\n      };\n\n      State.prototype.move = function(table, index, move) {\n        return Cube.moveTables[table][index][move];\n      };\n\n      State.prototype.pruning = function(table, index) {\n        return pruning(Cube.pruningTables[table], index);\n      };\n\n      State.prototype.moves1 = function() {\n        if (this.lastMove !== null) {\n          return nextMoves1[this.lastMove / 3 | 0];\n        } else {\n          return allMoves1;\n        }\n      };\n\n      State.prototype.minDist1 = function() {\n        var d1, d2;\n        d1 = this.pruning('sliceFlip', N_SLICE1 * this.flip + this.slice);\n        d2 = this.pruning('sliceTwist', N_SLICE1 * this.twist + this.slice);\n        return max(d1, d2);\n      };\n\n      State.prototype.next1 = function(move) {\n        var next;\n        next = freeStates.pop();\n        next.parent = this;\n        next.lastMove = move;\n        next.depth = this.depth + 1;\n        next.flip = this.move('flip', this.flip, move);\n        next.twist = this.move('twist', this.twist, move);\n        next.slice = this.move('FRtoBR', this.slice * 24, move) / 24 | 0;\n        return next;\n      };\n\n      State.prototype.moves2 = function() {\n        if (this.lastMove !== null) {\n          return nextMoves2[this.lastMove / 3 | 0];\n        } else {\n          return allMoves2;\n        }\n      };\n\n      State.prototype.minDist2 = function() {\n        var d1, d2, index1, index2;\n        index1 = (N_SLICE2 * this.URtoDF + this.FRtoBR) * N_PARITY + this.parity;\n        d1 = this.pruning('sliceURtoDFParity', index1);\n        index2 = (N_SLICE2 * this.URFtoDLF + this.FRtoBR) * N_PARITY + this.parity;\n        d2 = this.pruning('sliceURFtoDLFParity', index2);\n        return max(d1, d2);\n      };\n\n      State.prototype.init2 = function(top) {\n        if (top == null) {\n          top = true;\n        }\n        if (this.parent === null) {\n          return;\n        }\n        this.parent.init2(false);\n        this.URFtoDLF = this.move('URFtoDLF', this.parent.URFtoDLF, this.lastMove);\n        this.FRtoBR = this.move('FRtoBR', this.parent.FRtoBR, this.lastMove);\n        this.parity = this.move('parity', this.parent.parity, this.lastMove);\n        this.URtoUL = this.move('URtoUL', this.parent.URtoUL, this.lastMove);\n        this.UBtoDF = this.move('UBtoDF', this.parent.UBtoDF, this.lastMove);\n        if (top) {\n          return this.URtoDF = this.move('mergeURtoDF', this.URtoUL, this.UBtoDF);\n        }\n      };\n\n      State.prototype.next2 = function(move) {\n        var next;\n        next = freeStates.pop();\n        next.parent = this;\n        next.lastMove = move;\n        next.depth = this.depth + 1;\n        next.URFtoDLF = this.move('URFtoDLF', this.URFtoDLF, move);\n        next.FRtoBR = this.move('FRtoBR', this.FRtoBR, move);\n        next.parity = this.move('parity', this.parity, move);\n        next.URtoDF = this.move('URtoDF', this.URtoDF, move);\n        return next;\n      };\n\n      return State;\n\n    })();\n    solution = null;\n    phase1search = function(state) {\n      var depth, m, ref2, results;\n      depth = 0;\n      results = [];\n      for (depth = m = 1, ref2 = maxDepth; 1 <= ref2 ? m <= ref2 : m >= ref2; depth = 1 <= ref2 ? ++m : --m) {\n        phase1(state, depth);\n        if (solution !== null) {\n          break;\n        }\n        results.push(depth++);\n      }\n      return results;\n    };\n    phase1 = function(state, depth) {\n      var len, m, move, next, ref2, ref3, results;\n      if (depth === 0) {\n        if (state.minDist1() === 0) {\n          if (state.lastMove === null || (ref2 = state.lastMove, indexOf.call(allMoves2, ref2) < 0)) {\n            return phase2search(state);\n          }\n        }\n      } else if (depth > 0) {\n        if (state.minDist1() <= depth) {\n          ref3 = state.moves1();\n          results = [];\n          for (m = 0, len = ref3.length; m < len; m++) {\n            move = ref3[m];\n            next = state.next1(move);\n            phase1(next, depth - 1);\n            freeStates.push(next);\n            if (solution !== null) {\n              break;\n            } else {\n              results.push(void 0);\n            }\n          }\n          return results;\n        }\n      }\n    };\n    phase2search = function(state) {\n      var depth, m, ref2, results;\n      state.init2();\n      results = [];\n      for (depth = m = 1, ref2 = maxDepth - state.depth; 1 <= ref2 ? m <= ref2 : m >= ref2; depth = 1 <= ref2 ? ++m : --m) {\n        phase2(state, depth);\n        if (solution !== null) {\n          break;\n        }\n        results.push(depth++);\n      }\n      return results;\n    };\n    phase2 = function(state, depth) {\n      var len, m, move, next, ref2, results;\n      if (depth === 0) {\n        if (state.minDist2() === 0) {\n          return solution = state.solution();\n        }\n      } else if (depth > 0) {\n        if (state.minDist2() <= depth) {\n          ref2 = state.moves2();\n          results = [];\n          for (m = 0, len = ref2.length; m < len; m++) {\n            move = ref2[m];\n            next = state.next2(move);\n            phase2(next, depth - 1);\n            freeStates.push(next);\n            if (solution !== null) {\n              break;\n            } else {\n              results.push(void 0);\n            }\n          }\n          return results;\n        }\n      }\n    };\n    freeStates = (function() {\n      var m, ref2, results;\n      results = [];\n      for (x = m = 0, ref2 = maxDepth + 1; 0 <= ref2 ? m <= ref2 : m >= ref2; x = 0 <= ref2 ? ++m : --m) {\n        results.push(new State);\n      }\n      return results;\n    })();\n    state = freeStates.pop().init(this);\n    phase1search(state);\n    freeStates.push(state);\n    if (solution.length > 0) {\n      solution = solution.substring(0, solution.length - 1);\n    }\n    return solution;\n  };\n\n  Cube.scramble = function() {\n    return Cube.inverse(Cube.random().solve());\n  };\n\n}).call(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./assets/vendor/cubejs/solve.js\n ** module id = 3\n ** module chunks = 0\n **/"],"sourceRoot":""}